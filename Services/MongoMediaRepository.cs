using Microsoft.Extensions.Options;
using MongoDB.Bson;
using MongoDB.Driver;
using MongoDbBookstoreApi.Models;
using System.Diagnostics;

namespace MongoDbBookstoreApi.Services
{
    public class MongoMediaRepository : IMediaRepository
    {
        private readonly IMongoCollection<MediaFile> _collection;

        public MongoMediaRepository(IOptions<BookStoreDatabaseSettings> bookStoreDatabaseSettings)
        {
            var mongoClient = new MongoClient(
                bookStoreDatabaseSettings.Value.ConnectionString);

            var mongoDatabase = mongoClient.GetDatabase(
                bookStoreDatabaseSettings.Value.DatabaseName);
            _collection = mongoDatabase.GetCollection<MediaFile>("MediaFiles");
        }

        //public async Task<string> SaveAsync(MediaFile media)
        //{
        //    await _collection.InsertOneAsync(media);
        //    return media.Id!;
        //}

        public async Task<String> UpsertAsync(MediaFile media)
        {
            try
            {
                // Filter to find the existing document by its ID
                var filter = Builders<MediaFile>.Filter.Eq(m => m.Id, media.Id);

                // Replace the document if found; otherwise, insert it
                var options = new ReplaceOptions { IsUpsert = true };

                var result = await _collection.ReplaceOneAsync(filter, media, options);
                // 1. If we inserted a new doc, return the new ID generated by Mongo
                if (result.UpsertedId != null)
                {
                    return result.UpsertedId.ToString();
                }
                return media.Id!;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error inserting/updating media file with ID {media.Id}: {ex.Message}");
                throw;
            }
        }

        public async Task<MediaFile?> GetByIdAsync(string id)
        {
            try
            {
                return await _collection.Find(m => m.Id == id).FirstOrDefaultAsync();
            }
            catch (Exception ex)
            { 
                Debug.WriteLine($"Error retrieving media file with ID {id}: {ex.Message}");
                throw;
            }
        }

        public async Task<IEnumerable<MediaFileDto>> GetAllMediaAsync()
        {
            try
            {
                // Use an empty filter to match all documents
                var filter = Builders<MediaFile>.Filter.Empty;
                // Retrieve all documents and convert to a List
                List<MediaFile> files = await _collection.Find(filter).ToListAsync();

                return files.Select(f => new MediaFileDto
                {
                    Id = f.Id.ToString(),
                    FileName = f.FileName,
                    Length = f.Data.LongLength
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error retrieving media files");
                throw;
            }
        }

        public async Task DeleteMediaAsync(string id)
        {
            //if (!ObjectId.TryParse(id, out var objectId))
            try
            {
                await _collection.DeleteOneAsync(x => x.Id == id);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error deleting media file with ID {id}: {ex.Message}");
                throw;
            }
        }
    }
}
